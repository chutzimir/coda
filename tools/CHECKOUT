#!/bin/csh -f
#
# Script to do a clean checkout of a unique version of Coda sources
# from RCS.  A unique Coda version id looks like "C401_8Jan1997_16h28m"
#
# Usage: 
#	cd <empty checkout directory>
#       ln -s <pathname of RCS tree root> RCS
#	rcsco -r<unique Coda version id> CHECKOUT
#	./CHECKOUT ID=<unique Coda version id>
#
# Created:  M. Satyanarayanan (Jan 1997)


# First define global variables
set UNIQUEID = 
set ERRORMSG = "Usage: CHECKOUT ID=<unique Coda version id>"
set PLATFORM = `uname`

switch ($PLATFORM)

case NetBSD:
		set RCSCO = "co"
		breaksw

case Mach:
		set RCSCO = "rcsco"
		breaksw

case Linux:	
		set RCSCO = "co"
		breaksw

default:	
		echo "Unknown platform $PLATFORM..."
		exit -1
endsw


# Next process input args 

# We only have one arg for now, but I bet we'll soon find 
# the need for more ... 

while ($1 != "")

set KEYWORD = `expr $1 : '\(.*\)=.*'`
set VALUE = `expr $1 : '.*=\(.*\)'`

switch ($KEYWORD)

case ID:
	set UNIQUEID = $VALUE
	breaksw

default:
	echo "$ERRORMSG"
	exit
	breaksw
endsw

shift
end

if ($UNIQUEID == "") then
	echo "$ERRORMSG"
	exit
endif
	 
# Verify this directory is empty
foreach X (*)
echo $X
if ($X == "CHECKOUT") continue
if ($X == "RCS") continue
echo "ERROR: Directory should be empty except for CHECKOUT and RCS"
exit -1
end

# Now iterate through the RCS tree in depth-first traversal, making 
# subdirectories and checking out files as you go.  Directories with 
# names "ATTIC" or "Attic" are ignored, because they are assumed to 
# contain obsolete files.    Only files of the form "*,v" are assumed to
# be worth checking out.  This code would be much shorter if C-shell
# supported recursion!

# CAVEAT:  the code below works only up to a nesting level of 4.  
# If the RCS tree evolves to be deeper than that, this script has
# to be fixed appropriately.  Should be pretty straightforward unless
# you exceed C-shell limits!

# Remember where we started
set HERE = `pwd`

# Deal with level 0 files
echo "Checking out top level..."
set TOPFILES = RCS/*,v
foreach TF ($TOPFILES)
if ($TF == "CHECKOUT,v") continue
$RCSCO -r$UNIQUEID  $TF
end

# Begin loop for level 0 directories

# We should be able to just use "RCS/*" in foreach()
# but pmax_mach's C-shell has problems when "RCS/*" yields
# empty string (i.e., empty directory).  Hence use "ls -a" 
# and skip "." and ".."
set ALIST = `ls -a RCS`

foreach A ($ALIST)
if ($A == ".") continue
if ($A == "..") continue
if ($A == "ATTIC") continue
cd $HERE
if (!(-d RCS/$A)) continue
echo "Checking out $A ..."
mkdir $A
cd $A
ln -s ../RCS/$A RCS

# Checkout files at level 1
$RCSCO -r$UNIQUEID  RCS/*,v

# Begin loop for level 1 directories
set BLIST = `ls -a RCS`
foreach B ($BLIST)
if ($B == ".") continue
if ($B == "..") continue
if ($B == "ATTIC") continue
cd $HERE/$A
if (!(-d RCS/$B)) continue
echo "Checking out $A/$B ..."
mkdir $B
cd $B
ln -s ../RCS/$B RCS

# Checkout files at level 2
$RCSCO -r$UNIQUEID  RCS/*,v

# Begin loop for level 2 directories
set CLIST = `ls -a RCS`
foreach C ($CLIST)
if ($C == ".") continue
if ($C == "..") continue
if ($C == "ATTIC") continue
cd $HERE/$A/$B
if (!(-d RCS/$C)) continue
echo "Checking out $A/$B/$C ..."
mkdir $C
cd $C
ln -s ../RCS/$C RCS

# Checkout files at level 3
$RCSCO -r$UNIQUEID  RCS/*,v

# Begin loop for level 3 directories
set DLIST = `ls -a RCS`
foreach D ($DLIST)
if ($D == ".") continue
if ($D == "..") continue
if ($D == "ATTIC") continue
cd $HERE/$A/$B/$C
if (!(-d RCS/$D)) continue
echo "Checking out $A/$B/$C/$D ..."
mkdir $D
cd $D
ln -s ../RCS/$D RCS

# Checkout files at level 4
$RCSCO -r$UNIQUEID  RCS/*,v

# Make sure there are no level 4 directories!
set ELIST = `ls -a RCS`
foreach E ($ELIST)
if ($E == ".") continue
if ($E == "..") continue
if (-d RCS/$E) then
echo "Arrrggghhhh ..... nesting more than 4 levels deep"
exit -1
endif
end

#end of nested loops for A through D
end
end
end
end



# Embarrassing ad hoc junk; ideally this should be empty

cd $HERE/rvm-src/rvm
ln -s dummy_cthreads.h cthreads.h


# End of checkout procedure
echo "---- CHECKOUT done ----"
exit 0
