#ifndef _BLURB_
#define _BLURB_
/*

            Coda: an Experimental Distributed File System
                             Release 3.1

          Copyright (c) 1987-1996 Carnegie Mellon University
                         All Rights Reserved

Permission  to  use, copy, modify and distribute this software and its
documentation is hereby granted,  provided  that  both  the  copyright
notice  and  this  permission  notice  appear  in  all  copies  of the
software, derivative works or  modified  versions,  and  any  portions
thereof, and that both notices appear in supporting documentation, and
that credit is given to Carnegie Mellon University  in  all  documents
and publicity pertaining to direct or indirect use of this code or its
derivatives.

CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
ANY DERIVATIVE WORK.

Carnegie  Mellon  encourages  users  of  this  software  to return any
improvements or extensions that  they  make,  and  to  grant  Carnegie
Mellon the rights to redistribute these changes without encumbrance.
*/

static char *rcsid = "/afs/cs/project/coda-rvb/cvs/src/coda-4.0.1/kernel-src/vfs/mach/cfs_mach.c,v 1.2 1997/01/07 18:44:12 rvb Exp";
#endif /*_BLURB_*/


/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */

/*
 * This code was written for the Coda file system at Carnegie Mellon
 * University.  Contributers include David Steere, James Kistler, and
 * M. Satyanarayanan.  */

/*
 * HISTORY
 * cfs_mach.c,v
 * Revision 1.2  1996/01/02 16:56:49  bnoble
 * Added support for Coda MiniCache and raw inode calls (final commit)
 *
 * Revision 1.1.2.1  1995/12/20 01:57:14  bnoble
 * Added CFS-specific files
 *
 */

/* Mach-specific routines for the cfs code */
#ifdef	__MACH__

#include <cfs/cfs.h>
#include <cfs/cfs_vnodeops.h>

/* Forward declarations for the vfs operations */
int cfs_mount_mach   __P((VFS_T *, char *, caddr_t));
int cfs_unmount_mach __P((VFS_T *));
int cfs_statfs_mach  __P((VFS_T *, struct statfs *));
int cfs_sync_mach    __P((VFS_T *));
int cfs_vget_mach    __P((VFS_T *, struct vnode **, struct fid *));

/* Definition of the vfs operation vector */

struct vfsops cfs_vfsops = {
	cfs_mount_mach,
	cfs_unmount_mach,
	cfs_root,            /* cfs_root is of correct type */
	cfs_statfs_mach,
	cfs_sync_mach,
	cfs_vget_mach
};

/* Definition of the vnode operation vector */

struct vnodeops cfs_vnodeops = {
	cfs_mk_open,
	cfs_mk_close,
	cfs_mk_rdwr,
	cfs_mk_ioctl,
	cfs_mk_select,
	cfs_mk_getattr,
	cfs_mk_setattr,
	cfs_mk_access,
	cfs_mk_lookup,
	cfs_mk_create,
	cfs_mk_remove,
	cfs_mk_link,
	cfs_mk_rename,
	cfs_mk_mkdir,
	cfs_mk_rmdir,
	cfs_mk_readdir,
	cfs_mk_symlink,
	cfs_mk_readlink,
	cfs_mk_fsync,
	cfs_mk_inactive,
	cfs_mk_bmap,
	cfs_mk_strategy,
	cfs_mk_bread,
	cfs_mk_brelse,
	cfs_mk_lockctl,
	cfs_mk_fid,
	cfs_mk_page_read,
	cfs_mk_page_write,
	cfs_mk_readdir,		/* read1dir */
	cfs_mk_freefid
};

/************************ Pseudo-device wrappers */

int
vcopen(dev)
    dev_t dev;
{
    return vc_nb_open(dev, 0, 0, GLOBAL_PROC);
}

int
vcclose(dev)
    dev_t dev;
{
    return vc_nb_close(dev, 0, 0, GLOBAL_PROC);
}

int 
vcread(dev, uiop)
    dev_t       dev;
    struct uio *uiop;
{
    return vc_nb_read(dev,uiop,0);
}

int
vcwrite(dev, uiop)
    dev_t       dev;
    struct uio *uiop;
{
    return vc_nb_write(dev,uiop,0);
}

int
vcioctl(dev, cmd, addr, flag)
    dev_t    dev;
    int      cmd;
    caddr_t  addr;
    int      flag;
{
    return vc_nb_ioctl(dev,cmd,addr,flag,GLOBAL_PROC);
}

int
vcselect(dev, flag)
    dev_t  dev;
    int    flag;
{
    return vc_nb_select(dev,flag,GLOBAL_PROC);
}

/************************ VFS operation wrappers */

int
cfs_mount_mach(vfsp, path, data)
    VFS_T *vfsp;
    char *path;
    caddr_t data;
{
    return cfs_mount(vfsp, path, data, NULL, GLOBAL_PROC);
}

int
cfs_unmount_mach(vfsp)
    VFS_T *vfsp;
{
    return cfs_unmount(vfsp, 0, GLOBAL_PROC);
}

int
cfs_statfs_mach(vfsp, sbp)
    register VFS_T *vfsp;
    struct statfs *sbp;
{
    reutrn cfs_statfs(vfsp, sbp, GLOBAL_PROC);
}

int
cfs_sync_mach(vfsp)
    VFS_T *vfsp;
{
    return cfs_sync(vfsp,0,GLOBAL_CRED,GLOBAL_PROC);
}

int
cfs_vget_mach(vfsp, vpp, fidp)
    VFS_T         *vfsp;
    struct vnode **vpp;
    struct fid    *fidp;
{
    return (cfs_fhtovp(vfsp, fidp, NULL, vpp, NULL, NULL));
}

/* Vnode operation wrappers */

int
cfs_mk_open(vpp, flag, cred)
    register struct vnode **vpp;
    int flag;
    struct ucred *cred;
{
    return cfs_open(vpp, flag, cred, GLOBAL_PROC);
}

/*ARGSUSED*/
/*
 * Close the cache file used for I/O and notify Venus.
 */
int
cfs_mk_close(vp, flag, cred)
    struct vnode *vp;
    int flag;
    struct ucred *cred;
{ 
    return cfs_close(vp, flag, cred, GLOBAL_PROC);
}

int
cfs_mk_rdwr(vp, uiop, rw, ioflag, cred)
    struct vnode *vp;
    struct uio *uiop;
    enum uio_rw rw;
    int ioflag;
    struct ucred *cred;
{ 
    return cfs_rdwr(vp, uiop, rw, ioflag, cred, GLOBAL_PROC);
}

/*ARGSUSED*/
int
cfs_mk_ioctl(vp, com, data, flag, cred)
    struct vnode *vp;
    int com;
    caddr_t data;
    int flag;
    struct ucred *cred;
    struct proc  *p;
{ 
    return cfs_ioctl(vp, com, data, flag, cred, GLOBAL_PROC);
}

/*ARGSUSED*/
int
cfs_mk_select(vp, which, cred)
    struct vnode *vp;
    int which;
    struct ucred *cred;
{
    return cfs_select(vp, which, cred, GLOBAL_PROC);
}

int
cfs_mk_getattr(vp, vap, cred)
    struct vnode *vp;
    struct vattr *vap;
    struct ucred *cred;
{
    return cfs_getattr(vp, vap, cred, GLOBAL_PROC);
}

int
cfs_mk_setattr(vp, vap, cred)
    register struct vnode *vp;
    register struct vattr *vap;
    struct ucred *cred;
{ 
    return cfs_setattr(vp, vap, cred, GLOBAL_PROC);
}

int
cfs_mk_access(vp, mode, cred)
    struct vnode *vp;
    int mode;
    struct ucred *cred;
{ 
    return cfs_access(vp, mode, cred, GLOBAL_PROC);
}

int
cfs_mk_readlink(vp, uiop, cred)
    struct vnode *vp;
    struct uio *uiop;
    struct ucred *cred;
{ 
    return cfs_readlink(vp, uiop, cred, GLOBAL_PROC);
}

/*ARGSUSED*/
int
cfs_mk_fsync(vp, cred)
    struct vnode *vp;
    struct ucred *cred;
{ 
    return cfs_fsync(vp, cred, GLOBAL_PROC);
}

/*ARGSUSED*/
int
cfs_mk_inactive(vp, cred)
    struct vnode *vp;
    struct ucred *cred;
{ 
    return cfs_inactive(vp, cred, GLOBAL_PROC);
}

/*
 * Remote file system operations having to do with directory manipulation.
 */

int
cfs_mk_lookup(dvp, nm, vpp, cred)
    struct vnode *dvp;
    char *nm;
    struct vnode **vpp;
    struct ucred *cred;
    sruct proc *p;
{ 
    return cfs_lookup(dvp, nm, vpp, cred, GLOBAL_PROC);
}

/*ARGSUSED*/
int
cfs_mk_create(dvp, nm, va, exclusive, mode, vpp, cred)
    struct vnode *dvp;
    char *nm;
    struct vattr *va;
    enum vcexcl exclusive;
    int mode;
    struct vnode **vpp;
    struct ucred *cred;
{
    return cfs_create(dvp, nm, va, exclusive, mode, vpp, cred, GLOBAL_PROC);
}

int
cfs_mk_remove(dvp, nm, cred)
    struct vnode *dvp;
    char *nm;
    struct ucred *cred;
{ 
    return cfs_remove(dvp, nm, cred, GLOBAL_PROC);
}


int
cfs_mk_link(vp, tdvp, tnm, cred)
    struct vnode *vp;
    struct vnode *tdvp;
    char *tnm;
    struct ucred *cred;
{
    return cfs_link(vp, tdvp, tnm, cred, GLOBAL_PROC);
}

int
cfs_mk_rename(odvp, onm, ndvp, nnm, cred)
    struct vnode *odvp;
    char *onm;
    struct vnode *ndvp;
    char *nnm;
    struct ucred *cred;
{
    return cfs_rename(odvp, onm, ndvp, nnm, cred, GLOBAL_PROC);
}

int
cfs_mk_mkdir(dvp, nm, va, vpp, cred)
    struct vnode *dvp;
    char *nm;
    register struct vattr *va;
    struct vnode **vpp;
    struct ucred *cred;
{ 
    return cfs_mkdir(dvp, nm, va, vpp, cred, GLOBAL_PROC);
}

int
cfs_mk_rmdir(dvp, nm, cred)
    struct vnode *dvp;
    char *nm;
    struct ucred *cred;
{ 
    return cfs_rmdir(dvp, nm, cred, GLOBAL_PROC);
}

int
cfs_mk_symlink(tdvp, tnm, tva, lnm, cred)
    struct vnode *tdvp;
    char *tnm;
    struct vattr *tva;
    char *lnm;
    struct ucred *cred;
{
    return cfs_symlink(tdvp, tnm, tva, lnm, cred, GLOBAL_PROC);
}

/*
 * Read directory entries.
 */
int
cfs_mk_readdir(vp, uiop, cred)
    struct vnode *vp;
    register struct uio *uiop;
    struct ucred *cred;
{ 
    int fake_eofflag;
    u_long fake_cookies;
    int    ncookies = 0;

    return cfs_readdir(vp, uiop, cred, &fake_eofflag, &fake_cookies,
		       ncookies, GLOBAL_PROC);
}

/*
 * Convert from file system blocks to device blocks
 */
int
cfs_mk_bmap(vp, bn, vpp, bnp)
    struct vnode *vp;	/* file's vnode */
    daddr_t bn;		/* fs block number */
    struct vnode **vpp;	/* RETURN vp of device */
    daddr_t *bnp;		/* RETURN device block number */
{ 
    return cfs_bmap(vp, bn, vpp, bnp, GLOBAL_PROC);
}

int
cfs_mk_strategy(bp)
    register struct buf *bp;
{ 
    return cfs_strategy(bp, GLOBAL_PROC);
}


/* How one looks up a vnode given a device/inode pair: */

int
cfs_grab_vnode(dev, ino, vpp)
	 dev_t dev; ino_t ino; struct vnode **vpp;
{
    /* This is like VFS_VGET() or igetinode()! */
    struct fs *fs = igetfs(dev);
    if (fs == NULL) {
	printf("cfs_grab_vnode: igetfs(%d) returns NULL\n", dev);
	return(ENXIO);
    }
    *vpp = iget(dev, fs, ino);
    if (*vpp == NULL) {
	printf("cfs_grab_vnode: iget(%d, %x, %d) returns NULL\n", 
	       dev, fs, ino);
	return(ENOENT);
    }
    return(0);
}

/* How to print out the attributes of a vnode. */

void
print_vattr( attr )
	struct vattr *attr;
{
	printf("getattr: mode %d uid %d gid %d fsid %d rdev %d\n",
		(int)attr->va_mode, (int)attr->va_uid,
		(int)attr->va_gid, (int)attr->va_fsid, (int)attr->va_rdev);

	printf("	nodeid %d nlink %d size %d blocksize %d blocks %d\n",
		(int)attr->va_nodeid, (int)attr->va_nlink, (int)attr->va_size,
		(int)attr->va_blocksize,(int)attr->va_blocks);

	printf("	atime sec %d usec %d",
		(int)attr->va_atime.tv_sec, (int)attr->va_atime.tv_usec);
	printf("	mtime sec %d usec %d",
		(int)attr->va_mtime.tv_sec, (int)attr->va_mtime.tv_usec);
	printf("	ctime sec %d usec %d\n",
		(int)attr->va_ctime.tv_sec, (int)attr->va_ctime.tv_usec);
}

/* How to print a ucred */
print_cred(cred)
	struct ucred *cred;
{

	int i;

	printf("ref %d uid %d ruid %d gid %d rgid %d pag %d\n",
		cred->id_ref,cred->id_uid,cred->id_ruid,
		cred->id_gid,cred->id_rgid,cred->id_pag);

	for (i=0; i < 16; i++)
		printf("%d groups %d ",i,cred->id_groups[i]);
	printf("\n");

}


#endif /* MACH */



