%{#ifndef _BLURB_
#define _BLURB_
/*

            Coda: an Experimental Distributed File System
                             Release 4.0

          Copyright (c) 1987-1996 Carnegie Mellon University
                         All Rights Reserved

Permission  to  use, copy, modify and distribute this software and its
documentation is hereby granted,  provided  that  both  the  copyright
notice  and  this  permission  notice  appear  in  all  copies  of the
software, derivative works or  modified  versions,  and  any  portions
thereof, and that both notices appear in supporting documentation, and
that credit is given to Carnegie Mellon University  in  all  documents
and publicity pertaining to direct or indirect use of this code or its
derivatives.

CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
ANY DERIVATIVE WORK.

Carnegie  Mellon  encourages  users  of  this  software  to return any
improvements or extensions that  they  make,  and  to  grant  Carnegie
Mellon the rights to redistribute these changes without encumbrance.
*/

static char *rcsid = "$Header$";
#endif /*_BLURB_*/%}




/*

                         IBM COPYRIGHT NOTICE

                          Copyright (C) 1986
             International Business Machines Corporation
                         All Rights Reserved

This  file  contains  some  code identical to or derived from the 1986
version of the Andrew File System ("AFS"), which is owned by  the  IBM
Corporation.    This  code is provded "AS IS" and IBM does not warrant
that it is free of infringement of  any  intellectual  rights  of  any
third  party.    IBM  disclaims  liability of any kind for any damages
whatsoever resulting directly or indirectly from use of this  software
or  of  any  derivative work.  Carnegie Mellon University has obtained
permission to distribute this code, which is based on Version 2 of AFS
and  does  not  contain the features and enhancements that are part of
Version 3 of AFS.  Version 3 of  AFS  is  commercially  available  and
supported by Transarc Corporation, Pittsburgh, PA.

*/




Server Prefix "S";
Subsystem  "auth2";

/* The portal for RPC.  Must exist in /etc/services. */
#define AUTH_SERVICE	"coda_auth"

/* The subsysid for auth server; use RPC2_SUBSYSBYID */
#define AUTH_SUBSYSID	1993253

/* Return codes from AuthChangePassword */
#define AUTH_SUCCESS	0
#define AUTH_FAILED	1
#define AUTH_DENIED	2
#define AUTH_BADKEY	3
#define AUTH_READONLY	4

/* Vice Ioctls for authentication calls */
/*  #define AUTH_GETVICEID	16	Not yet implemented */
#define AUTH_SETTOKENS		3
#define AUTH_GETTOKENS		9
#define AUTH_DELETETOKENS	8

/* The result of an AuthGetToken() call is to return an ClearToken and an SecretToken.
	The two contain similar information, but SecretToken has its fields permuted, has
	a magic string for self-validation and 	has noise fields to resist plaintext attacks.
*/

typedef RPC2_Byte AuthMagic[16];
#define AUTH_MAGICVALUE "authentication"

typedef
    RPC2_Struct
	{
	AuthMagic MagicString;	/* Value should be equal to the magic string of the day. If
						so, encrypted token is valid. */
	RPC2_Integer AuthHandle;	/* Handle, might come in useful for revocation in future */
	RPC2_Integer Noise1;
	RPC2_Integer ViceId;		/* Whom is this token for? */
	RPC2_Integer BeginTimestamp;	/* Seconds since Jan 1 1970 before which token is invalid */
	RPC2_Integer Noise2;
	RPC2_Integer EndTimestamp;	/* Seconds since Jan 1 1970 after which token is invalid */
	RPC2_Integer Noise3;
	RPC2_EncryptionKey  HandShakeKey;	/* For use by server's GetKeys() routine */
	RPC2_Integer Noise4;
	}
	SecretToken;

typedef
	RPC2_Byte EncryptedSecretToken[56];
typedef
    RPC2_Struct
	{
	RPC2_Integer AuthHandle;
	RPC2_EncryptionKey HandShakeKey;
	RPC2_Integer ViceId;
	RPC2_Integer BeginTimestamp;
	RPC2_Integer EndTimestamp;
	}
	ClearToken;

#define AUTHFILENAME "auth2.pw"

/* Magic password size for crunch_pwd_DES. */
#define CRUNCHPWSIZE	16

%{
extern void U_HostToNetClearToken(ClearToken *cToken);
extern void U_NetToHostClearToken(ClearToken *cToken);
extern int U_Authenticate(char *uName, char *uPasswd, ClearToken *cToken, EncryptedSecretToken sToken);
extern int U_ChangePassword(char *uName, char *newPasswd, char *myName, char *myPasswd);
extern void U_InitRPC();
extern char *U_AuthErrorMsg(int rc);
extern int U_BindToServer(char *DefAuthHost, char *uName, char *uPasswd, RPC2_Handle *RPCid);
extern char *U_Error(int rc);
extern int U_SetLocalTokens(int setPag, ClearToken *cToken, EncryptedSecretToken sToken);
extern int U_GetLocalTokens(ClearToken *cToken, EncryptedSecretToken sToken);
extern int U_DeleteLocalTokens();

/* The password records in the password file; never transmitted across RPC interface */
#define AUTHPWSIZE		16
struct AuthRecord
	{
	char passwd[AUTHPWSIZE];
	};

%}



/* NOTE: The auth server accepts only secure connections based on the stored password of a user */

AuthNewConn (IN RPC2_Integer seType, IN RPC2_Integer secLevel, IN RPC2_Integer encType, IN RPC2_CountedBS cIdent) NEW_CONNECTION;

AuthChangePasswd (IN RPC2_Integer viceId, IN RPC2_String newPasswd);

/* Change a user's password. You can change your own password always.
Caller must be a system administrator to change someone else's
password. */

AuthGetTokens (OUT EncryptedSecretToken sToken, OUT ClearToken cToken);

		/*  Get back tokens for use in communicating with File Servers.  This is effectively a
		    key distribution algorithm, since the tokens contain a session key.  You use
		    a secure connection to get to the auth server, then get tokens, then
		    use the auth token to establish a secure connection with a file server.  The
		    sToken is encrypted with a key known only to the auth server and the file servers.
		    It is transmitted by the client as the ClientIdent field of the RPC2_Bind() to 
		    the file server.
		*/

AuthChangeUser (IN RPC2_Integer viceId, IN RPC2_EncryptionKey initKey, IN RPC2_String otherInfo);
		/* Changes entry for a user. Caller must be a system administrator.  */

AuthNewUser (IN RPC2_Integer viceId, IN RPC2_EncryptionKey initKey, IN RPC2_String otherInfo);
		/* Adds a new user to Vice. Caller must be a system administrator.
		    User must not exist already */

AuthDeleteUser (IN RPC2_Integer viceId);
		/* Deletes a user from vice.  User must exist. Note that viceId remains in use.
		    However the user cannot authenticate himself to Vice.
		    Caller must be a system administrator.
		*/



AuthNameToId (IN RPC2_String viceName, OUT RPC2_Integer viceId);
	    /* Returns the vice id corr to vice name.  Returns  AUTHFAILED
	    if  viceName is a bogus vice name. Else returns AUTHSUCCESS.
	    */

AuthQuit();	/* Logout from server: marks connection as not in use; gc it later. Can't just unbind
	since response will not get back */
